// `Object` is the shared monotype for this Scheme.
//  - it is generated by a parser
//  - the 'vm' module...
//      1.  compiles objects into 'ch3 assembly code' objects
//      2.  executes ch3 assembly code objects using other objects
//      ?.  performs GC on a relevant subset of all allocated nodes.
//          - this leaks code objects, which is great, because we need them to be loaded permanently
//          - can dispose of code objects post-execution in the future

// ABORTED: unbox basic datatypes, switch to object tagging.
// WHY? Because in this form, it is easy to add custom object instances using OO, which C++ supports
// very well.
// This improves the experience for an end-user, making this more easily embeddable.

#pragma once

#include <map>
#include <array>
#include <sstream>
#include <functional>
#include <bitset>
#include <ostream>
#include <cstddef>
#include <cstdint>
#include <ios>
#include <cassert>

#include "core.hh"
#include "intern.hh"
#include "feedback.hh"

//
// Objects:
//

enum class GranularObjectType {
    // native primitives:
    Null, Eof,
    Boolean,
    Fixnum,
    Float32,
    Float64,
    Rune,
    InternedSymbol,
    String,
    Pair,
    Vector,

    // VMA = VM Accelerator
    // The VM uses some data-structures so frequently that they can be optimized.
    // These are also 'opaque' to the user.
    VMA_CallFrame,
    VMA_Closure,

    // EXT = Extension objects
    EXT_Callable
};

class BoxedObject;

class OBJECT {
private:
    union Data64 {
        size_t raw: 64;
          
        // must be a multiple of '8', so ends in '000'
        // actually always a ptr to 'IBoxedObject'
        BoxedObject* ptr;
        struct { size_t tag: 3; size_t word_offset: 61; } ptr_unwrapped;
        

        // signed fixnum: ends in '1 << 0 = 0b1'
        struct { size_t tag: 1; int64_t val: 63; } signed_fixnum;
        // interned symbol: ends in '1 << 1 = 0b10'
        struct { size_t tag: 2; int64_t val: 62; } interned_symbol;
        // float32: ends in '1 << 2 = 0b100'
        struct { uint32_t tag: 3; uint32_t pad: 29; float val; } f32;
        // unicode character: ends in '1 << 3 = 0b1000'
        struct { uint64_t tag: 4; uint64_t rune: 60; } rune;
        // boolean: ends in '1 << 4 = 0b10000'
        struct { uint64_t tag: 5; uint64_t truth: 59; } boolean;
        // null: ends in '1 << 5 = 0b100000'
        struct { uint64_t tag: 6; uint64_t pad: 58; } null;
        // eof: ends in '1 << 6 = 0b1000000'
        struct { uint64_t tag: 7; uint64_t pad: 57; } eof;
        // undef: ends in '1 << 7 = 0b10000000'
        struct { uint64_t tag: 8; uint64_t pad: 56; } undef;
    };
    Data64 m_data;
public:
    OBJECT() = default;
    OBJECT(bool v);
    OBJECT(BoxedObject* ptr);
    static OBJECT s_boolean_t;
    static OBJECT s_boolean_f;
public: // unboxed objects
    static OBJECT make_undef();
    static OBJECT make_integer(my_ssize_t val);
    static OBJECT make_interned_symbol(IntStr s);
    static OBJECT make_float32(float f32);
    static OBJECT make_boolean(bool v);
    static OBJECT make_null();
    static OBJECT make_eof();
public: // boxed objects
    // static OBJECT make_port(std::string file_path, std::ios_base::openmode mode);
    static OBJECT make_generic_boxed(BoxedObject* obj);
    static OBJECT make_float64(double f64);
    static OBJECT make_pair(OBJECT head, OBJECT tail);
    static OBJECT make_string(size_t byte_count, char* mv_bytes);
public:
    bool is_boxed_object() const { return m_data.ptr_unwrapped.tag == 0; }
    bool is_signed_fixnum() const { return m_data.signed_fixnum.tag == (1u<<0); }
    bool is_interned_symbol() const { return m_data.interned_symbol.tag == (1u<<1); }
    bool is_float32() const { return m_data.f32.tag == (1u<<2); }
    bool is_uchar() const { return m_data.rune.tag == (1u<<3); }
    bool is_boolean() const { return m_data.boolean.tag == (1u<<4); }
    bool is_boolean(bool v) const { return is_boolean() && as_raw() == (v ? s_boolean_t.as_raw() : s_boolean_f.as_raw()); }
    bool is_null() const { return m_data.null.tag == (1u<<5); }
    bool is_eof() const { return m_data.eof.tag == (1u<<6); }
    bool is_undef() const { return m_data.undef.tag == (1u<<7); }
public:
    inline bool is_pair() const;
    inline bool is_float64() const;
    inline bool is_closure() const;
    inline bool is_ext_callable() const;
    bool is_string() const;

    inline GranularObjectType kind() const;
public:
    inline size_t as_raw() const;
    inline my_ssize_t as_signed_fixnum() const;
    inline bool as_boolean() const;
    inline BoxedObject* as_ptr() const;
    inline IntStr as_interned_symbol() const;
    inline float as_float32() const;
    inline double as_float64() const;
public:
    inline double to_double() const;
public:
    Data64 raw_data() const { return m_data; }
};

class BoxedObject {
    friend GranularObjectType obj_kind(OBJECT obj);

private:
    GranularObjectType m_kind;

protected:
    explicit BoxedObject(GranularObjectType kind);
    virtual ~BoxedObject() = default;

public:
    [[nodiscard]] GranularObjectType kind();
};

class Float64Object: public BoxedObject {
protected:
    double m_value;
public:
    explicit Float64Object(double float_pt)
    :   BoxedObject(GranularObjectType::Float64),
        m_value(float_pt)
    {}
public:
    double value() const { return m_value; }
};

class StringObject: public BoxedObject {
private:
    size_t m_count;
    char* m_bytes;
public:
    StringObject()
    :   BoxedObject(GranularObjectType::String),
        m_count(),
        m_bytes()
    {}
    StringObject(size_t count, char* bytes)
    :   StringObject()
    {
        m_count = count;
        m_bytes = bytes;
    }
public:
    inline size_t count() const { return m_count; }
    inline char* bytes() const { return m_bytes; }
};

class PairObject: public BoxedObject {
private:
    OBJECT m_car;
    OBJECT m_cdr;
public:
    PairObject() 
    :   PairObject(OBJECT::make_null(), OBJECT::make_null())
    {}
    explicit PairObject(OBJECT car, OBJECT cdr)
    :   BoxedObject(GranularObjectType::Pair),
        m_car(car),
        m_cdr(cdr)
    {}
public:
    [[nodiscard]] inline OBJECT car() const { return m_car; }
    [[nodiscard]] inline OBJECT cdr() const { return m_cdr; }
    inline void set_car(OBJECT o) { m_car = o; }
    inline void set_cdr(OBJECT o) { m_cdr = o; }
};

class VectorObject: public BoxedObject {
private:
    size_t m_count;
    OBJECT* m_array;
public:
    VectorObject()
    :   BoxedObject(GranularObjectType::Vector),
        m_count(),
        m_array()
    {}
    VectorObject(size_t count, OBJECT* mv_array)
    :   VectorObject()
    {
        m_count = count;
        m_array = mv_array;
    }
public:
    [[nodiscard]] inline size_t count() const { return m_count; }
    [[nodiscard]] inline OBJECT* array() const { return m_array; }
};

//
// Builtins for VM:
//  - these are used to accelerate the VM.
//  - todo: move to a different file
//

using VmExpID = size_t;

class VMA_CallFrameObject: public BoxedObject {
private:
    VmExpID m_x;
    PairObject* m_e;
    OBJECT m_r;
    VMA_CallFrameObject* m_opt_parent;

public:
    VMA_CallFrameObject(
        VmExpID x,
        PairObject* e,
        OBJECT r,
        VMA_CallFrameObject* opt_parent
    )
    :   BoxedObject(GranularObjectType::VMA_CallFrame),
        m_x(x),
        m_e(e),
        m_r(r),
        m_opt_parent(opt_parent)
    {}

public:
    VmExpID x() const { return m_x; }
    PairObject* e() const { return m_e; }
    OBJECT r() const { return m_r; }
    VMA_CallFrameObject* parent() const { return m_opt_parent; }
};

class VMA_ClosureObject: public BoxedObject {
  private:
    VmExpID m_body;         // the body expression to evaluate
    PairObject* m_e;        // the environment to use
    OBJECT m_vars;         // the formal variables captured

  public:
    VMA_ClosureObject(
        VmExpID body,
        PairObject* e,
        OBJECT vars
    )
    :   BoxedObject(GranularObjectType::VMA_Closure),
        m_body(body),
        m_e(e),
        m_vars(vars)
    {}

  public:
    [[nodiscard]] VmExpID body() const { return m_body; }
    [[nodiscard]] PairObject* e() const { return m_e; }
    [[nodiscard]] OBJECT vars() const { return m_vars; }
};

//
// EXT_: Extension objects: used to inject C++ code into the runtime
//

using EXT_CallableCb = std::function<OBJECT(OBJECT args)>;

class EXT_CallableObject: public BoxedObject {
  private:
    EXT_CallableCb m_cb;
    OBJECT m_e;
    OBJECT m_vars;

  public:
    EXT_CallableObject(EXT_CallableCb cb, OBJECT e, OBJECT vars)
    :   BoxedObject(GranularObjectType::EXT_Callable),
        m_cb(std::move(cb)),
        m_e(e),
        m_vars(vars)
    {}

  public:
    EXT_CallableCb const& cb() const { return m_cb; }
    OBJECT e() const { return m_e; }
    OBJECT vars() const { return m_vars; }
};

//
//
// Inline functions:
//
//

//
// decls
//

std::ostream& operator<<(std::ostream& out, const OBJECT& obj);

inline GranularObjectType obj_kind(OBJECT object);
inline OBJECT car(OBJECT object);
inline OBJECT cdr(OBJECT object);
template <typename... Objects> OBJECT list(Objects... objs);
template <size_t n> std::array<OBJECT, n> extract_args(OBJECT pair_list, bool is_variadic = false);
inline OBJECT cons(OBJECT head, OBJECT tail);
inline OBJECT boolean(bool v);
inline bool is_boolean(OBJECT o);
inline bool is_char(OBJECT o);
inline bool is_null(OBJECT o);
inline bool is_pair(OBJECT o);
inline bool is_procedure(OBJECT o);
inline bool is_symbol(OBJECT o);
inline bool is_integer(OBJECT o);
inline bool is_float(OBJECT o);
inline bool is_number(OBJECT o);
inline bool is_string(OBJECT o);
inline bool is_vector(OBJECT o);

bool is_eqn(OBJECT e1, OBJECT e2);
bool is_eq(OBJECT e1, OBJECT e2);
bool is_eqv(OBJECT e1, OBJECT e2);
bool is_equal(OBJECT e1, OBJECT e2);

inline my_ssize_t count_list_items(OBJECT pair_list);

//
// defs
//

template <typename... Objects>
OBJECT list() {
    return OBJECT::make_null();
}
template <typename... Objects>
OBJECT list(OBJECT first, Objects... objs) {
    return OBJECT::make_pair(first, list(objs...));
}

template <size_t n> 
std::array<OBJECT, n> extract_args(OBJECT pair_list, bool is_variadic) {
    // reading upto `n` objects into an array:
    OBJECT rem_list = pair_list;
    std::array<OBJECT, n> out{};
    size_t index = 0;
    while (!rem_list.is_null() && index < n) {
        assert(rem_list.is_pair() && "expected arg list to be a pair-list");
        out[index++] = car(rem_list);
        rem_list = cdr(rem_list);
    }
    
    // checking that the received array is OK:
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    {
        if (!is_variadic && !rem_list.is_null()) {
            std::stringstream error_ss;
            error_ss
                << "extract_args: too many arguments to a non-variadic procedure: expected " << n;
            error(error_ss.str());
            throw SsiError();
        }
        if (index < n) {
            std::stringstream error_ss;
            error_ss 
                << "extract_args: too few arguments: received " << index << ", but expected at least " << n; 
            error(error_ss.str());
            throw SsiError();
        }
    }
#endif

    // returning array:
    return out;
}

inline BoxedObject::BoxedObject(GranularObjectType kind)
:   m_kind(kind) {}

inline OBJECT car(OBJECT object) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (obj_kind(object) != GranularObjectType::Pair) {
        error("car: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject*>(object.as_ptr())->car();
}
inline OBJECT cdr(OBJECT object) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (obj_kind(object) != GranularObjectType::Pair) {
        error("cdr: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject*>(object.as_ptr())->cdr();
}

OBJECT cons(OBJECT head, OBJECT tail) {
    return OBJECT::make_pair(head, tail);
}

OBJECT boolean(bool v) {
    return OBJECT::make_boolean(v);
}

inline bool is_boolean(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Boolean;
}
inline bool is_null(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Null;
}
inline bool is_pair(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Pair;
}
inline bool is_procedure(OBJECT o) {
    return (
        obj_kind(o) == GranularObjectType::VMA_Closure ||
        obj_kind(o) == GranularObjectType::EXT_Callable
    );
}
inline bool is_symbol(OBJECT o) {
    return obj_kind(o) == GranularObjectType::InternedSymbol;
}
inline bool is_integer(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Fixnum;
}
inline bool is_float(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Float64;
}
inline bool is_number(OBJECT o) {
    return is_integer(o) || is_float(o);
}
inline bool is_string(OBJECT o) {
    return obj_kind(o) == GranularObjectType::String;
}
inline bool is_vector(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Vector;
}

inline my_ssize_t count_list_items(OBJECT pair_list) {
    my_ssize_t var_ctr = 0;
    for (
        OBJECT rem_var_rib = pair_list;
        rem_var_rib.is_pair();
        rem_var_rib = cdr(rem_var_rib)
    ) {
        var_ctr++;
    }
    return var_ctr;
}