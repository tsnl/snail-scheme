// `Object` is the shared monotype for this Scheme.
//  - it is generated by a parser
//  - the 'vm' module...
//      1.  compiles objects into 'ch3 assembly code' objects
//      2.  executes ch3 assembly code objects using other objects
//      ?.  performs GC on a relevant subset of all allocated nodes.
//          - this leaks code objects, which is great, because we need them to be loaded permanently
//          - can dispose of code objects post-execution in the future

// ABORTED: unbox basic datatypes, switch to object tagging.
// WHY? Because in this form, it is easy to add custom object instances using OO, which C++ supports
// very well.
// This improves the experience for an end-user, making this more easily embeddable.

#pragma once

#include <map>
#include <array>
#include <sstream>
#include <functional>
#include <bitset>
#include <ostream>
#include <cstddef>
#include <cstdint>
#include <vector>
#include <ios>
#include <cassert>

#include "core.hh"
#include "intern.hh"
#include "feedback.hh"

//
// Objects:
//

enum class GranularObjectType {
    // native primitives:
    Null, Eof,
    Boolean,
    Fixnum,
    Float32,
    Float64,
    Rune,
    InternedSymbol,
    String,
    Pair,
    Vector,

    // VMA = VM Accelerator
    // The VM uses some data-structures so frequently that they can be optimized.
    // These are also 'opaque' to the user.
    VMA_CallFrame,
    VMA_Closure,

    // EXT = Extension objects
    EXT_Callable
};

class BaseBoxedObject;

class OBJECT {
    // NOTE: 'nullptr' <=> 'null' for interop with C++
public:
    inline static size_t const PTR_TAG = 0b0;
    inline static size_t const FIXNUM_TAG = 0b1;
    inline static size_t const INTSTR_TAG = 0b10;
    inline static size_t const HALFWORD_TAG = 0b100;
    inline static size_t const FL32_TAG  = (0b000 << 3) | HALFWORD_TAG;
    inline static size_t const RUNE_TAG  = (0b001 << 3) | HALFWORD_TAG;
    inline static size_t const BOOL_TAG  = (0b010 << 3) | HALFWORD_TAG;
    inline static size_t const EOF_TAG   = (0b011 << 3) | HALFWORD_TAG;
    inline static size_t const UNDEF_TAG = (0b100 << 3) | HALFWORD_TAG;

private:
    union Data64LittleEndian {
        size_t raw: 64;
          
        // must be a multiple of '8', so ends in '000'
        // actually always a ptr to 'BaseBoxedObject'
        BaseBoxedObject* ptr;
        struct { size_t tag: 3; size_t word_offset: 61; } ptr_unwrapped;
        
        // signed fixnum: ends in '1 << 0 = 0b1'
        struct { size_t tag: 1; int64_t val: 63; } signed_fixnum;
        // interned symbol: ends in '1 << 1 = 0b10'
        struct { size_t tag: 2; int64_t val: 62; } interned_symbol;
        
        // half-words: ends in '1 << 2 = 0b100' aka HALFWORD_TAG
        // next 3MSB in tag are used for finer division
        struct { uint32_t tag: 6; uint32_t pad: 26; float val; } f32;
        struct { uint64_t tag: 6; uint64_t rune: 58; } rune;
        struct { uint64_t tag: 6; uint64_t truth: 58; } boolean;
        struct { uint64_t tag: 6; uint64_t pad: 58; } eof;
        struct { uint64_t tag: 6; uint64_t pad: 58; } undef;
    };
    Data64LittleEndian m_data;
public:
    explicit OBJECT() = default;
    explicit OBJECT(bool v);
    explicit OBJECT(BaseBoxedObject* ptr);
    static OBJECT s_boolean_t;
    static OBJECT s_boolean_f;
public: // unboxed objects
    static OBJECT make_undef();
    static OBJECT make_integer(my_ssize_t val);
    static OBJECT make_interned_symbol(IntStr s);
    static OBJECT make_float32(float f32);
    static OBJECT make_boolean(bool v);
    static OBJECT make_null();
    static OBJECT make_eof();
public: // boxed objects
    // static OBJECT make_port(std::string file_path, std::ios_base::openmode mode);
    static OBJECT make_generic_boxed(BaseBoxedObject* obj);
    static OBJECT make_float64(double f64);
    static OBJECT make_pair(OBJECT head, OBJECT tail);
    static OBJECT make_string(size_t byte_count, char* mv_bytes);
public:
    bool is_null() const { return m_data.raw == 0; }
    bool is_boxed_object() const { return m_data.ptr_unwrapped.tag == PTR_TAG && !is_null(); }
    bool is_integer() const { return m_data.signed_fixnum.tag == FIXNUM_TAG; }
    bool is_interned_symbol() const { return m_data.interned_symbol.tag == INTSTR_TAG; }
    bool is_float32() const { return m_data.f32.tag == FL32_TAG; }
    bool is_uchar() const { return m_data.rune.tag == RUNE_TAG; }
    bool is_boolean() const { return m_data.boolean.tag == BOOL_TAG; }
    bool is_boolean(bool v) const { return is_boolean() && as_raw() == (v ? s_boolean_t.as_raw() : s_boolean_f.as_raw()); }
    bool is_eof() const { return m_data.eof.tag == EOF_TAG; }
    bool is_undef() const { return m_data.undef.tag == UNDEF_TAG; }
    bool is_list() const { return is_pair() || is_null(); }
public:
    inline bool is_pair() const;
    inline bool is_float64() const;
    inline bool is_closure() const;
    inline bool is_ext_callable() const;
    inline bool is_string() const;
    inline bool is_vector() const;

    inline GranularObjectType kind() const;
public:
    inline size_t as_raw() const;
    inline my_ssize_t as_signed_fixnum() const;
    inline bool as_boolean() const;
    inline BaseBoxedObject* as_ptr() const;
    inline IntStr as_interned_symbol() const;
    inline float as_float32() const;
    inline double as_float64() const;
public:
    inline double to_double() const;
public:
    Data64LittleEndian raw_data() const { return m_data; }

public:
    OBJECT& operator=(OBJECT const& other) = default;
};

class BaseBoxedObject {
    friend GranularObjectType obj_kind(OBJECT obj);

private:
    GranularObjectType m_kind;

protected:
    explicit BaseBoxedObject(GranularObjectType kind);
    virtual ~BaseBoxedObject() = default;

public:
    [[nodiscard]] GranularObjectType kind();
};
static_assert(sizeof(OBJECT) == sizeof(void*));


class Float64Object: public BaseBoxedObject {
protected:
    double m_value;
public:
    explicit Float64Object(double float_pt)
    :   BaseBoxedObject(GranularObjectType::Float64),
        m_value(float_pt)
    {}
public:
    double value() const { return m_value; }
};

class StringObject: public BaseBoxedObject {
private:
    size_t m_count;
    char* m_bytes;
public:
    StringObject()
    :   BaseBoxedObject(GranularObjectType::String),
        m_count(),
        m_bytes()
    {}
    StringObject(size_t count, char* bytes)
    :   StringObject()
    {
        m_count = count;
        m_bytes = bytes;
    }
public:
    inline size_t count() const { return m_count; }
    inline char* bytes() const { return m_bytes; }
};

class PairObject: public BaseBoxedObject {
private:
    OBJECT m_car;
    OBJECT m_cdr;
public:
    PairObject() 
    :   PairObject(OBJECT::make_null(), OBJECT::make_null())
    {}
    explicit PairObject(OBJECT car, OBJECT cdr)
    :   BaseBoxedObject(GranularObjectType::Pair),
        m_car(car),
        m_cdr(cdr)
    {}
public:
    [[nodiscard]] inline OBJECT car() const { return m_car; }
    [[nodiscard]] inline OBJECT cdr() const { return m_cdr; }
    inline void set_car(OBJECT o) { m_car = o; }
    inline void set_cdr(OBJECT o) { m_cdr = o; }
};

class VectorObject: public BaseBoxedObject {
private:
    std::vector<OBJECT> m_impl;

public:
    VectorObject()
    :   BaseBoxedObject(GranularObjectType::Vector),
        m_impl()
    {}
    VectorObject(std::vector<OBJECT>&& items)
    :   BaseBoxedObject(GranularObjectType::Vector),
        m_impl(std::move(items))
    {}

private:
    void push_many_without_reserve();
    
    template <typename... TArgs>
    void push_many_without_reserve(OBJECT object, TArgs... args);

public:
    void reserve(size_t min_new_capacity);

    void push(OBJECT object);
    
    template <typename... TArgs>
    void push_many(TArgs... args);

public:
    OBJECT& operator[] (size_t i) {
        return m_impl[i];
    }

public:
    [[nodiscard]] inline size_t count() const { return m_impl.size(); }
    [[nodiscard]] inline OBJECT* array() { return m_impl.data(); }
    inline std::vector<OBJECT>& as_cpp_vec() { return m_impl; }
};

//
// Builtins for VM:
//  - these are used to accelerate the VM.
//  - todo: move to a different file
//

using VmExpID = size_t;

class VMA_CallFrameObject: public BaseBoxedObject {
private:
    VmExpID m_x;
    OBJECT m_e;
    OBJECT m_r;
    VMA_CallFrameObject* m_opt_parent;

public:
    VMA_CallFrameObject(
        VmExpID x,
        OBJECT e,
        OBJECT r,
        VMA_CallFrameObject* opt_parent
    )
    :   BaseBoxedObject(GranularObjectType::VMA_CallFrame),
        m_x(x),
        m_e(e),
        m_r(r),
        m_opt_parent(opt_parent)
    {}

public:
    VmExpID x() const { return m_x; }
    OBJECT e() const { return m_e; }
    OBJECT r() const { return m_r; }
    VMA_CallFrameObject* parent() const { return m_opt_parent; }
};

class VMA_ClosureObject: public BaseBoxedObject {
  private:
    VmExpID m_body;    // the body expression to evaluate
    OBJECT m_e;        // the environment to use

  public:
    VMA_ClosureObject(VmExpID body, OBJECT e)
    :   BaseBoxedObject(GranularObjectType::VMA_Closure),
        m_body(body),
        m_e(e)
    {}

  public:
    [[nodiscard]] VmExpID body() const { return m_body; }
    [[nodiscard]] OBJECT e() const { return m_e; }
};

//
// EXT_: Extension objects: used to inject C++ code into the runtime
//

using EXT_CallableCb = std::function<OBJECT(OBJECT args)>;

class EXT_CallableObject: public BaseBoxedObject {
  private:
    EXT_CallableCb m_cb;
    OBJECT m_e;
    OBJECT m_vars;

  public:
    EXT_CallableObject(EXT_CallableCb cb, OBJECT e, OBJECT vars)
    :   BaseBoxedObject(GranularObjectType::EXT_Callable),
        m_cb(std::move(cb)),
        m_e(e),
        m_vars(vars)
    {}

  public:
    EXT_CallableCb const& cb() const { return m_cb; }
    OBJECT e() const { return m_e; }
    OBJECT vars() const { return m_vars; }
};

//
//
// Inline functions:
//
//

//
// decls
//

std::ostream& operator<<(std::ostream& out, const OBJECT& obj);

inline GranularObjectType obj_kind(OBJECT object);
inline OBJECT car(OBJECT object);
inline OBJECT cdr(OBJECT object);
inline void set_car(OBJECT pair, OBJECT a);
inline void set_cdr(OBJECT pair, OBJECT d);
template <typename... Objects> OBJECT list(Objects... objs);
template <size_t n> std::array<OBJECT, n> extract_args(OBJECT pair_list, bool is_variadic = false);
inline OBJECT cons(OBJECT head, OBJECT tail);
inline OBJECT boolean(bool v);
inline bool is_boolean(OBJECT o);
inline bool is_char(OBJECT o);
inline bool is_null(OBJECT o);
inline bool is_pair(OBJECT o);
inline bool is_procedure(OBJECT o);
inline bool is_symbol(OBJECT o);
inline bool is_integer(OBJECT o);
inline bool is_float(OBJECT o);
inline bool is_number(OBJECT o);
inline bool is_string(OBJECT o);
inline bool is_vector(OBJECT o);

bool is_eqn(OBJECT e1, OBJECT e2);
bool is_eq(OBJECT e1, OBJECT e2);
bool is_eqv(OBJECT e1, OBJECT e2);
bool is_equal(OBJECT e1, OBJECT e2);

inline my_ssize_t count_list_items(OBJECT pair_list);

inline OBJECT vector_length(OBJECT vec);
inline OBJECT vector_ref(OBJECT vec, OBJECT index);
inline void vector_set(OBJECT vec, OBJECT index, OBJECT v);

//
// defs
//

template <typename... Objects>
OBJECT list() {
    return OBJECT::make_null();
}
template <typename... Objects>
OBJECT list(OBJECT first, Objects... objs) {
    return OBJECT::make_pair(first, list(objs...));
}

template <size_t n> 
std::array<OBJECT, n> extract_args(OBJECT pair_list, bool is_variadic) {
    // reading upto `n` objects into an array:
    OBJECT rem_list = pair_list;
    std::array<OBJECT, n> out;
    size_t index = 0;
    while (!rem_list.is_null() && index < n) {
        assert(rem_list.is_pair() && "expected arg list to be a pair-list");
        out[index++] = car(rem_list);
        rem_list = cdr(rem_list);
    }
    
    // checking that the received array is OK:
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    {
        if (!is_variadic && !rem_list.is_null()) {
            std::stringstream error_ss;
            error_ss
                << "extract_args: too many arguments to a non-variadic procedure: expected " << n;
            error(error_ss.str());
            throw SsiError();
        }
        if (index < n) {
            std::stringstream error_ss;
            error_ss 
                << "extract_args: too few arguments: received " << index << ", but expected at least " << n; 
            error(error_ss.str());
            throw SsiError();
        }
    }
#endif

    // returning array:
    return out;
}

inline BaseBoxedObject::BaseBoxedObject(GranularObjectType kind)
:   m_kind(kind) {}

inline OBJECT car(OBJECT object) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (!object.is_pair()) {
        error("car: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject*>(object.as_ptr())->car();
}
inline OBJECT cdr(OBJECT object) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (obj_kind(object) != GranularObjectType::Pair) {
        error("cdr: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject*>(object.as_ptr())->cdr();
}
inline void set_car(OBJECT pair, OBJECT a) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (!is_pair(pair)) {
        error("set-car!: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject*>(pair.as_ptr())->set_car(a);
}
inline void set_cdr(OBJECT pair, OBJECT d) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (!is_pair(pair)) {
        error("set-cdr!: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject*>(pair.as_ptr())->set_cdr(d);
}

OBJECT cons(OBJECT head, OBJECT tail) {
    return OBJECT::make_pair(head, tail);
}

OBJECT boolean(bool v) {
    return OBJECT::make_boolean(v);
}

inline bool is_boolean(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Boolean;
}
inline bool is_null(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Null;
}
inline bool is_pair(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Pair;
}
inline bool is_procedure(OBJECT o) {
    return (
        obj_kind(o) == GranularObjectType::VMA_Closure ||
        obj_kind(o) == GranularObjectType::EXT_Callable
    );
}
inline bool is_symbol(OBJECT o) {
    return obj_kind(o) == GranularObjectType::InternedSymbol;
}
inline bool is_integer(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Fixnum;
}
inline bool is_float(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Float64;
}
inline bool is_number(OBJECT o) {
    return is_integer(o) || is_float(o);
}
inline bool is_string(OBJECT o) {
    return obj_kind(o) == GranularObjectType::String;
}
inline bool is_vector(OBJECT o) {
    return obj_kind(o) == GranularObjectType::Vector;
}

inline my_ssize_t count_list_items(OBJECT pair_list) {
    my_ssize_t var_ctr = 0;
    for (
        OBJECT rem_var_rib = pair_list;
        rem_var_rib.is_pair();
        rem_var_rib = cdr(rem_var_rib)
    ) {
        var_ctr++;
    }
    return var_ctr;
}

inline OBJECT vector_length(OBJECT vec) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (!vec.is_vector()) {
        std::stringstream ss;
        ss << "vector-length: expected 'vec' as first argument, got: " << vec << std::endl;
        error(ss.str());
        throw SsiError();
    }
#endif
    return OBJECT::make_integer(dynamic_cast<VectorObject*>(vec.as_ptr())->count());
}
inline OBJECT vector_ref(OBJECT vec, OBJECT index) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (!vec.is_vector()) {
        std::stringstream ss;
        ss << "vector-ref: expected 'vec' as first argument, got: " << vec << std::endl;
        error(ss.str());
        throw SsiError();
    }
    if (!index.is_integer()) {
        std::stringstream ss;
        ss << "vector-ref: expected 'int' as second argument, got: " << vec << std::endl;
        error(ss.str());
        throw SsiError();
    }
#endif
    return dynamic_cast<VectorObject*>(vec.as_ptr())->operator[](index.as_signed_fixnum());
}
inline void vector_set(OBJECT vec, OBJECT index, OBJECT v) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (!vec.is_vector()) {
        std::stringstream ss;
        ss << "vector-set!: expected 'vec' as first argument, got: " << vec << std::endl;
        error(ss.str());
        throw SsiError();
    }
    if (!index.is_integer()) {
        std::stringstream ss;
        ss << "vector-set!: expected 'int' as second argument, got: " << vec << std::endl;
        error(ss.str());
        throw SsiError();
    }
#endif
    dynamic_cast<VectorObject*>(vec.as_ptr())->operator[](index.as_signed_fixnum()) = v;
}