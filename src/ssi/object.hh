// `Object` is the shared monotype for this Scheme.
//  - it is generated by a parser
//  - the 'vm' module...
//      1.  compiles objects into 'ch3 assembly code' objects
//      2.  executes ch3 assembly code objects using other objects
//      ?.  performs GC on a relevant subset of all allocated nodes.
//          - this leaks code objects, which is great, because we need them to be loaded permanently
//          - can dispose of code objects post-execution in the future

#pragma once

#include <map>
#include <cstddef>
#include <cstdint>

#include "core.hh"
#include "intern.hh"
#include "procedure.hh"

//
// Objects:
//

enum class ObjectKind {
    Nil,
    Boolean,
    Integer,
    FloatingPt,
    Symbol,
    String,
    Pair,
    Vector,
    Procedure
};

class Object {
  public:
    static std::map<Object const*, ObjectKind> s_nonnil_object_kind_map;
  protected:
    Object(ObjectKind kind);
    // ObjectKind is stored in a global std::map<Object*, ObjectKind>
    //  - RTTI is rare, especially with AOT type-checking
    //  - naive alternative: use a virtual 'kind' method or data member: bumps sizeof(AnyObject) from 2*size_t to 3*...
  public:
    ObjectKind kind() const;
};

class BoolObject: public Object {
  private:
    bool m_value;
  public:
    BoolObject()
    :   Object(ObjectKind::Boolean)
    {}
    explicit BoolObject(bool value)
    :   BoolObject()
    {
        m_value = value;
    }
  public:
    inline bool value() const { return m_value; }
};
class IntObject: public Object {
  private:
    my_ssize_t m_value;
  public:
    IntObject()
    :   Object(ObjectKind::Integer)
    {}
    explicit IntObject(my_ssize_t value)
    :   IntObject()
    {
        m_value = value;
    }
  public:
    inline my_ssize_t value() const { return m_value; }
};
class FloatObject: public Object {
  private:
    double m_value;
  public:
    FloatObject() 
    :   Object(ObjectKind::FloatingPt)
    {}
    explicit FloatObject(double value)
    :   FloatObject()
    {
        m_value = value;
    }
  public:
    inline double value() const { return m_value; }
};
class SymbolObject: public Object {
  private:
    IntStr m_name;
  public:
    SymbolObject() 
    :   Object(ObjectKind::Symbol)
    {}
    SymbolObject(IntStr name)
    :   SymbolObject()
    {
        m_name = name;
    }
  public:
    inline IntStr name() const { return m_name; }
};
class StringObject: public Object {
  private:
    size_t m_count;
    char* m_bytes;
  public:
    StringObject()
    :   Object(ObjectKind::String)
    {}
    StringObject(size_t count, char* bytes)
    :   StringObject()
    {
        m_count = count;
        m_bytes = bytes;
    }
  public:
    inline size_t count() const { return m_count; }
    inline char* bytes() const { return m_bytes; }
};
class PairObject: public Object {
  private:
    Object* m_car;
    Object* m_cdr;
  public:
    PairObject() 
    :   Object(ObjectKind::Pair)
    {}
    explicit PairObject(Object* car, Object* cdr)
    :   PairObject()
    {
        m_car = car;
        m_cdr = cdr;
    }
  public:
    inline Object* car() const { return m_car; }
    inline Object* cdr() const { return m_cdr; }
};
class VectorObject: public Object {
  private:
    size_t   m_count;
    Object** m_array;
  public:
    VectorObject()
    :   Object(ObjectKind::Vector)
    {}
    VectorObject(size_t count, Object** mv_array)
    :   VectorObject()
    {
        m_count = count;
        m_array = mv_array;
    }
  public:
    inline size_t count() const { return m_count; }
    inline Object** array() const { return m_array; }
};
// class ProcObject: public Object {
//   private:
//     Object* m_body;
//     Object* m_args_list;
//   public:
//     explicit ProcObject(Object* body, Object* implicit_args_vector, Object* explicit_arg_names_list)
//     :   m_body(body),
// };

//
//
// Inline functions:
//
//

//
// decls
//

template <typename... Objects> Object* list(Objects... objs);
inline ObjectKind objkind(Object* object);

//
// defs
//

template <typename... Objects>
Object* list() {
    return nullptr;
}
template <typename... Objects>
Object* list(Object* first, Objects... objs) {
    return new PairObject(first, list(objs...));
}

inline ObjectKind Object::kind() const {
    return Object::s_nonnil_object_kind_map[this];
}
inline ObjectKind objkind(Object* object) {
    if (object) {
        return object->kind();
    } else {
        return ObjectKind::Nil;
    }
}
