// `Object` is the shared monotype for this Scheme.
//  - it is generated by a parser
//  - the 'vm' module...
//      1.  compiles objects into 'ch3 assembly code' objects
//      2.  executes ch3 assembly code objects using other objects
//      ?.  performs GC on a relevant subset of all allocated nodes.
//          - this leaks code objects, which is great, because we need them to be loaded permanently
//          - can dispose of code objects post-execution in the future

#pragma once

#include <map>
#include <array>
#include <sstream>
#include <cstddef>
#include <cstdint>

#include "core.hh"
#include "intern.hh"
#include "procedure.hh"
#include "feedback.hh"

//
// Objects:
//

enum class ObjectKind {
    // native primitives:
    Nil,
    Boolean,
    Integer,
    FloatingPt,
    Symbol,
    String,
    Pair,
    Vector,
    Procedure,

    // VMA = VM Accelerator
    VMA_CallFrame,
    VMA_EnvRib
};

class Object {
  public:
    static std::map<Object const*, ObjectKind> s_non_nil_object_kind_map;
  protected:
    explicit Object(ObjectKind kind);
    // ObjectKind is stored in a global std::map<Object*, ObjectKind>
    //  - RTTI is rare, especially with AOT type-checking
    //  - naive alternative: use a virtual 'kind' method or data member: bumps sizeof(AnyObject) from 2*size_t to 3*...
  public:
    [[nodiscard]] ObjectKind kind() const;
};

class BoolObject: public Object {
  private:
    static BoolObject const t_storage;
    static BoolObject const f_storage;
  public:
    static BoolObject const* t;
    static BoolObject const* f;
  private:
    bool m_value;
  private:
    BoolObject()
    :   Object(ObjectKind::Boolean),
        m_value()
    {}
    explicit BoolObject(bool value)
    :   BoolObject()
    {
        m_value = value;
    }
  public:
    [[nodiscard]] inline bool value() const { return m_value; }
};
class IntObject: public Object {
  private:
    my_ssize_t m_value;
  public:
    IntObject()
    :   Object(ObjectKind::Integer),
        m_value()
    {}
    explicit IntObject(my_ssize_t value)
    :   IntObject()
    {
        m_value = value;
    }
  public:
    [[nodiscard]] inline my_ssize_t value() const { return m_value; }
};
class FloatObject: public Object {
  private:
    double m_value;
  public:
    FloatObject() 
    :   Object(ObjectKind::FloatingPt),
        m_value()
    {}
    explicit FloatObject(double value)
    :   FloatObject()
    {
        m_value = value;
    }
  public:
    [[nodiscard]] inline double value() const { return m_value; }
};
class SymbolObject: public Object {
  private:
    IntStr m_name;
  public:
    SymbolObject() 
    :   Object(ObjectKind::Symbol),
        m_name()
    {}
    explicit SymbolObject(IntStr name)
    :   SymbolObject()
    {
        m_name = name;
    }
  public:
    inline IntStr name() const { return m_name; }
};
class StringObject: public Object {
  private:
    size_t m_count;
    char* m_bytes;
  public:
    StringObject()
    :   Object(ObjectKind::String),
        m_count(),
        m_bytes()
    {}
    StringObject(size_t count, char* bytes)
    :   StringObject()
    {
        m_count = count;
        m_bytes = bytes;
    }
  public:
    inline size_t count() const { return m_count; }
    inline char* bytes() const { return m_bytes; }
};
class PairObject: public Object {
  private:
    Object const* m_car;
    Object const* m_cdr;
  public:
    PairObject() 
    :   Object(ObjectKind::Pair),
        m_car(),
        m_cdr()
    {}
    explicit PairObject(Object const* car, Object const* cdr)
    :   PairObject()
    {
        m_car = car;
        m_cdr = cdr;
    }
  public:
    [[nodiscard]] inline Object const* car() const { return m_car; }
    [[nodiscard]] inline Object const* cdr() const { return m_cdr; }
};
class VectorObject: public Object {
  private:
    size_t         m_count;
    Object const** m_array;
  public:
    VectorObject()
    :   Object(ObjectKind::Vector),
        m_count(),
        m_array()
    {}
    VectorObject(size_t count, Object const** mv_array)
    :   VectorObject()
    {
        m_count = count;
        m_array = mv_array;
    }
  public:
    [[nodiscard]] inline size_t count() const { return m_count; }
    [[nodiscard]] inline Object const** array() const { return m_array; }
};

// todo: replace these properties with a reference to a program on the active VM
class LambdaObject: public Object {
  private:
    Object const* m_body;
    Object const* m_args_list;
  public:
    LambdaObject()
    :   Object(ObjectKind::Procedure),
        m_body(),
        m_args_list()
    {}
    explicit LambdaObject(Object const* body, Object const* explicit_arg_names_list)
    : LambdaObject()
    {
        m_body = body;
        m_args_list = explicit_arg_names_list;
    }
};

//
// Builtins for VM:
//  - these are used to accelerate the VM.
//  - todo: move to a different file
//

using VmExpID = size_t;

class VMA_CallFrameObject: public Object {
  private:
    Object const* m_e;
    Object const* m_r;
    VmExpID m_x;
    VMA_CallFrameObject const* m_opt_parent;

  public:
    VMA_CallFrameObject(
        Object const* e,
        Object const* r,
        VmExpID x,
        VMA_CallFrameObject* parent
    )
    :   Object(ObjectKind::VMA_CallFrame),
        m_e(e),
        m_r(r),
        m_x(x),
        m_parent(parent)
    {}

  public:
    Object const* e() const { return m_e; }
    Object const* r() const { return m_r; }
    VmExpID x() const { return m_x; }
    Object const* parent() const { return m_parent; }
};

class VMA_EnvRib: public Object {
  private:
    std::vector< std::pair<IntStr, Object const*> > m_rib_vector;
    VMA_EnvRib const* m_opt_parent;

  public:
    VMA_EnvRib(VMA_EnvRib* opt_parent = nullptr);

  public:
    VMA_EnvRib* opt_parent();
    // todo: finish this off
};

//
//
// Inline functions:
//
//

//
// decls
//

inline ObjectKind objkind(Object const* object);
inline Object const* car(Object const* object);
inline Object const* cdr(Object const* object);
template <typename... Objects> Object const* list(Objects... objs);
template <size_t n> std::array<Object const*, n> extract_args(Object const* pair_list, bool is_variadic = false);

//
// defs
//

template <typename... Objects>
Object const* list() {
    return nullptr;
}
template <typename... Objects>
Object const* list(Object const* first, Objects... objs) {
    return new PairObject(first, list(objs...));
}

inline ObjectKind Object::kind() const {
    return Object::s_non_nil_object_kind_map[this];
}
inline ObjectKind objkind(Object const* object) {
    if (object) {
        return object->kind();
    } else {
        return ObjectKind::Nil;
    }
}

template <size_t n> 
std::array<Object const*, n> extract_args(Object const* pair_list, bool is_variadic) {
    // reading upto `n` objects into an array:
    Object const* rem_list = pair_list;
    std::array<Object const*, n> out{};
    size_t index = 0;
    while (rem_list && index < n) {
        out[index++] = car(rem_list);
        rem_list = cdr(rem_list);
    }
    
    // checking that the received array is OK:
#if !CONFIG_OPTIMIZED_MODE
    {
        if (!is_variadic && rem_list) {
            std::stringstream error_ss;
            error_ss
                << "extract_args: too many arguments to a non-variadic procedure: expected " << n;
            error(error_ss.str());
            throw SsiError();
        }
        if (index < n) {
            std::stringstream error_ss;
            error_ss 
                << "extract_args: too few arguments: received " << 1+index << ", but expected at least " << n; 
            error(error_ss.str());
            throw SsiError();
        }
    }
#endif

    // returning array:
    return out;
}

inline Object const* car(Object const* object) {
#if !CONFIG_OPTIMIZED_MODE
    if (objkind(object) != ObjectKind::Pair) {
        error("car: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject const*>(object)->car();
}
inline Object const* cdr(Object const* object) {
#if !CONFIG_OPTIMIZED_MODE
    if (objkind(object) != ObjectKind::Pair) {
        error("cdr: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject const*>(object)->cdr();
}
