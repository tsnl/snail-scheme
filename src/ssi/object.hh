// `Object` is the shared monotype for this Scheme.
//  - it is generated by a parser
//  - the 'vm' module...
//      1.  compiles objects into 'ch3 assembly code' objects
//      2.  executes ch3 assembly code objects using other objects
//      ?.  performs GC on a relevant subset of all allocated nodes.
//          - this leaks code objects, which is great, because we need them to be loaded permanently
//          - can dispose of code objects post-execution in the future

#pragma once

#include <map>
#include <array>
#include <sstream>
#include <cstddef>
#include <cstdint>

#include "core.hh"
#include "intern.hh"
#include "procedure.hh"
#include "feedback.hh"

//
// Objects:
//

enum class ObjectKind {
    // native primitives:
    Nil,
    Boolean,
    Integer,
    FloatingPt,
    Symbol,
    String,
    Pair,
    Vector,
    Procedure,

    // VMA = VM Accelerator
    // Custom structures used to keep the cache warm.
    VMA_CallFrame,
    VMA_Closure
};

class Object {
  public:
    static std::map<Object*, ObjectKind> s_non_nil_object_kind_map;
  protected:
    explicit Object(ObjectKind kind);
    // ObjectKind is stored in a global std::map<Object*, ObjectKind>
    //  - RTTI is rare, especially with AOT type-checking
    //  - naive alternative: use a virtual 'kind' method or data member: bumps sizeof(AnyObject) from 2*size_t to 3*...
  public:
    [[nodiscard]] ObjectKind kind();
};

class BoolObject: public Object {
  private:
    static BoolObject t_storage;
    static BoolObject f_storage;
  public:
    static BoolObject* t;
    static BoolObject* f;
  private:
    bool m_value;
  private:
    BoolObject()
    :   Object(ObjectKind::Boolean),
        m_value()
    {}
    explicit BoolObject(bool value)
    :   BoolObject()
    {
        m_value = value;
    }
  public:
    [[nodiscard]] inline bool value() const { return m_value; }
};
class IntObject: public Object {
  private:
    my_ssize_t m_value;
  public:
    IntObject()
    :   Object(ObjectKind::Integer),
        m_value()
    {}
    explicit IntObject(my_ssize_t value)
    :   IntObject()
    {
        m_value = value;
    }
  public:
    [[nodiscard]] inline my_ssize_t value() const { return m_value; }
};
class FloatObject: public Object {
  private:
    double m_value;
  public:
    FloatObject() 
    :   Object(ObjectKind::FloatingPt),
        m_value()
    {}
    explicit FloatObject(double value)
    :   FloatObject()
    {
        m_value = value;
    }
  public:
    [[nodiscard]] inline double value() const { return m_value; }
};
class SymbolObject: public Object {
  private:
    IntStr m_name;
  public:
    SymbolObject() 
    :   Object(ObjectKind::Symbol),
        m_name()
    {}
    explicit SymbolObject(IntStr name)
    :   SymbolObject()
    {
        m_name = name;
    }
  public:
    inline IntStr name() const { return m_name; }
};
class StringObject: public Object {
  private:
    size_t m_count;
    char* m_bytes;
  public:
    StringObject()
    :   Object(ObjectKind::String),
        m_count(),
        m_bytes()
    {}
    StringObject(size_t count, char* bytes)
    :   StringObject()
    {
        m_count = count;
        m_bytes = bytes;
    }
  public:
    inline size_t count() const { return m_count; }
    inline char* bytes() const { return m_bytes; }
};
class PairObject: public Object {
  private:
    Object* m_car;
    Object* m_cdr;
  public:
    PairObject() 
    :   Object(ObjectKind::Pair),
        m_car(),
        m_cdr()
    {}
    explicit PairObject(Object* car, Object* cdr)
    :   PairObject()
    {
        m_car = car;
        m_cdr = cdr;
    }
  public:
    [[nodiscard]] inline Object* car() const { return m_car; }
    [[nodiscard]] inline Object* cdr() const { return m_cdr; }
    inline void set_car(Object* o) { m_car = o; }
    inline void set_cdr(Object* o) { m_cdr = o; }
};
class VectorObject: public Object {
  private:
    size_t         m_count;
    Object** m_array;
  public:
    VectorObject()
    :   Object(ObjectKind::Vector),
        m_count(),
        m_array()
    {}
    VectorObject(size_t count, Object** mv_array)
    :   VectorObject()
    {
        m_count = count;
        m_array = mv_array;
    }
  public:
    [[nodiscard]] inline size_t count() const { return m_count; }
    [[nodiscard]] inline Object** array() const { return m_array; }
};

// todo: replace these properties with a reference to a program on the active VM
class LambdaObject: public Object {
  private:
    Object* m_body;
    Object* m_args_list;
  public:
    LambdaObject()
    :   Object(ObjectKind::Procedure),
        m_body(),
        m_args_list()
    {}
    explicit LambdaObject(Object* body, Object* explicit_arg_names_list)
    : LambdaObject()
    {
        m_body = body;
        m_args_list = explicit_arg_names_list;
    }
};

//
// Builtins for VM:
//  - these are used to accelerate the VM.
//  - todo: move to a different file
//

using VmExpID = size_t;

class VMA_CallFrameObject: public Object {
  private:
    VmExpID m_x;
    PairObject* m_e;
    Object* m_r;
    VMA_CallFrameObject* m_opt_parent;

  public:
    VMA_CallFrameObject(
        VmExpID x,
        PairObject* e,
        Object* r,
        VMA_CallFrameObject* opt_parent
    )
    :   Object(ObjectKind::VMA_CallFrame),
        m_x(x),
        m_e(e),
        m_r(r),
        m_opt_parent(opt_parent)
    {}

  public:
    VmExpID x() const { return m_x; }
    PairObject* e() const { return m_e; }
    Object* r() const { return m_r; }
    VMA_CallFrameObject* parent() const { return m_opt_parent; }
};

class VMA_ClosureObject: public Object {
  private:
    VmExpID m_body;         // the body expression to evaluate
    PairObject* m_e;        // the environment to use
    Object* m_vars;         // the formal variables captured

  public:
    VMA_ClosureObject(
        VmExpID body,
        PairObject* e,
        Object* vars
    )
    :   Object(ObjectKind::VMA_Closure),
        m_body(body),
        m_e(e),
        m_vars(vars)
    {}

  public:
    [[nodiscard]] VmExpID body() const { return m_body; }
    [[nodiscard]] PairObject* e() const { return m_e; }
    [[nodiscard]] Object* vars() const { return m_vars; }
};

//
//
// Inline functions:
//
//

//
// decls
//

inline ObjectKind obj_kind(Object* object);
inline Object* car(Object* object);
inline Object* cdr(Object* object);
template <typename... Objects> Object* list(Objects... objs);
template <size_t n> std::array<Object*, n> extract_args(Object* pair_list, bool is_variadic = false);
inline PairObject* cons(Object* head, Object* tail);

//
// defs
//

template <typename... Objects>
Object* list() {
    return nullptr;
}
template <typename... Objects>
Object* list(Object* first, Objects... objs) {
    return new PairObject(first, list(objs...));
}

inline ObjectKind Object::kind() {
    return Object::s_non_nil_object_kind_map[this];
}
inline ObjectKind obj_kind(Object* object) {
    if (object) {
        return object->kind();
    } else {
        return ObjectKind::Nil;
    }
}

template <size_t n> 
std::array<Object*, n> extract_args(Object* pair_list, bool is_variadic) {
    // reading upto `n` objects into an array:
    Object* rem_list = pair_list;
    std::array<Object*, n> out{};
    size_t index = 0;
    while (rem_list && index < n) {
        out[index++] = car(rem_list);
        rem_list = cdr(rem_list);
    }
    
    // checking that the received array is OK:
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    {
        if (!is_variadic && rem_list) {
            std::stringstream error_ss;
            error_ss
                << "extract_args: too many arguments to a non-variadic procedure: expected " << n;
            error(error_ss.str());
            throw SsiError();
        }
        if (index < n) {
            std::stringstream error_ss;
            error_ss 
                << "extract_args: too few arguments: received " << 1+index << ", but expected at least " << n; 
            error(error_ss.str());
            throw SsiError();
        }
    }
#endif

    // returning array:
    return out;
}

inline Object* car(Object* object) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (obj_kind(object) != ObjectKind::Pair) {
        error("car: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject*>(object)->car();
}
inline Object* cdr(Object* object) {
#if !CONFIG_DISABLE_RUNTIME_TYPE_CHECKS
    if (obj_kind(object) != ObjectKind::Pair) {
        error("cdr: expected argument object to be a pair");
        throw SsiError();
    }
#endif
    return static_cast<PairObject*>(object)->cdr();
}

PairObject* cons(Object* head, Object* tail) {
    return new PairObject(head, tail);
}