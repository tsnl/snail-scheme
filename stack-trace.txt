i00: FRAME (called 'frame0', caused by 'apply' of outer-most function applying 'call/cc')
  0: Frame0.c   = 0
  1: Frame0.f   = 0
  2: Frame0.ret = 0
s = 3

i01: CONSTANT
  a <- (integer 64)

i02: ARGUMENT
  3: (integer 64)
s = 4

i03: FRAME (called 'frame1', caused by 'call/cc')
  4: Frame1.c   = 0
  5: Frame1.f   = 0
  6: Frame1.ret = 1
s = 7

i04: CONTI (s=7)

i05: ARGUMENT
  7: continuation-closure: refers first argument (cb) into 'a', then 'nuate' to restore stack, then 'return' to return cb
     corresponds to 'frame1' by 'call/cc'
s = 8

i06: CLOSE (n free vars = 0) (caused by inner lambda, cb for 'call/cc')
s = 8
f = 8

i07: APPLY: applies closure produced by 'close' with argument 'conti'

i08: REFER_LOCAL

i09: RETURN: returns a closure (as expected, returns 'continuation-closure' pushed as 'ARGUMENT' after CONTI (i04, i05))
s = 4
f = 0

PREDICTION: after this invocation, 'a' contains a lambda which, when applied, will invoke 'nuate', then 'return'

i10: APPLY: as expected!

i11: REFER_LOCAL: 
  f=4,
  n=0
  Looks up the first and only argument: (integer 64) ***
  ---> this is how the bug occurs? Are we missing a 'frame'?

i12: NUATE